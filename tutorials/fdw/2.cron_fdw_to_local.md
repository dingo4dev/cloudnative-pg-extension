# Cron job to load foreign table data to local postgres table

You can set up a cron job to periodically load data from a foreign table (e.g., an Oracle table accessed via `oracle_fdw`) into a local PostgreSQL table. Below are the steps to achieve this.

## PG CRON

### Pre-requisites:

1. Ensure that the PostgreSQL server is running and accessible.
2. `pg_cron` in `shared_preload_libraries`:

    ``` yaml
      postgresql:
        shared_preload_libraries:
        - pg_cron
    ```

3. Ensure FDW is set up and working (see [Register the foreign data wrapper](1.register_fdw_table.md))


### Steps:

1. Install the `pg_cron` extension if it's not already installed:

    ```sql
    CREATE EXTENSION IF NOT EXISTS pg_cron;
    ```

2. Grant necessary permissions to the user who will run the cron jobs:

    ```sql
    GRANT USAGE ON SCHEMA cron TO app;
    -- Grant permissions on cron schema tables
    GRANT SELECT, UPDATE, INSERT, DELETE ON ALL TABLES IN SCHEMA cron TO app;
    ```

### Create tables and function to control cron jobs

1. Create a configuration table to manage which tables to sync and their sync frequency:

    ```sql
    CREATE TABLE public.cron_table_sync_config (
        id serial4 NOT NULL,
        source_table text NULL,
        target_table text NULL,
        primary_keys _text NOT NULL,
        target_updated_date_field text NULL,
        enabled bool DEFAULT true NULL,
        last_sync_time timestamp NULL,
        sync_frequency interval DEFAULT '00:01:00'::interval NULL,
        CONSTRAINT cron_table_sync_config_pkey PRIMARY KEY (id)
    );
    ```

2. Create a logging table to track sync operations:

    ```sql
    CREATE TABLE public.sync_operation_logs (
        id serial4 NOT NULL,
        source_table text NULL,
        target_table text NULL,
        start_time timestamp NULL,
        end_time timestamp NULL,
        status text NULL,
        rows_affected int8 NULL,
        message text NULL,
        created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
        CONSTRAINT sync_operation_logs_pkey PRIMARY KEY (id)
    );
    ```

3. Create function to sync data from foreign table to local table:

    ```sql
    CREATE OR REPLACE FUNCTION public.sync_table_data(source_table text, target_table text, pk_columns text[], updated_date_column text)
        RETURNS void
        LANGUAGE plpgsql
        AS $function$
        DECLARE
            pk_list text;
            column_list text;
            target_column_list text;
            update_list text;
            delete_condition text;
            temp_table_name text;
            sql_statement text;
        BEGIN
            -- Generate a unique temporary table name
            temp_table_name := 'temp_' || md5(random()::text || clock_timestamp()::text)::varchar(20);

            -- Get the column list dynamically
            SELECT string_agg(quote_ident(column_name), ', ')
            INTO target_column_list
            FROM information_schema.columns
            WHERE table_name = target_table
                AND table_schema = current_schema();
            
            SELECT string_agg(format('%I as %I', upper(col), col), ',') from (
                select quote_ident(column_name) col 
                FROM information_schema.columns
                WHERE table_name = target_table
                AND table_schema = current_schema()
            ) 
            INTO column_list;

            -- Create the primary key conflict list
            pk_list := array_to_string(array(SELECT quote_ident(pk) FROM unnest(pk_columns) pk), ', ');

            -- Create the update list for all columns except primary keys
            SELECT string_agg(format('%I = EXCLUDED.%I', column_name, column_name), ', ')
            INTO update_list
            FROM information_schema.columns
            WHERE table_name = target_table
            AND table_schema = current_schema()
            AND column_name != ALL(pk_columns);

            RAISE WARNING 'update_list: % ', update_list;	

            -- Create a temporary table with the source data
            EXECUTE format('CREATE TEMPORARY TABLE %I AS SELECT %s FROM %I', temp_table_name, column_list, source_table);

            RAISE WARNING 'CREATE TEMPORARY TABLE % AS SELECT % FROM %', temp_table_name, column_list, source_table;

            -- Perform the UPSERT operation
            sql_statement := format(
                'INSERT INTO %I SELECT %s FROM %I ON CONFLICT (%s) DO UPDATE SET %s ' ||
                'WHERE %I.%I IS DISTINCT FROM EXCLUDED.%I',
                target_table,
                target_column_list,
                temp_table_name,
                LOWER(pk_list),
                update_list,
                target_table,
                updated_date_column,
                updated_date_column
            );

        --	RAISE WARNING 'Perform UPSERT operation %', sql_statement;
            EXECUTE sql_statement;

            -- Create the delete condition
            SELECT string_agg(format('%I.%I IS NULL', temp_table_name, lower(pk)), ' AND ')
            INTO delete_condition
            FROM unnest(pk_columns) pk;

            -- Remove rows from target that don't exist in source
            sql_statement := format(
                'DELETE FROM %I WHERE NOT EXISTS (SELECT 1 FROM %I WHERE %s)',
                target_table,
                temp_table_name,
                array_to_string(array(
                    SELECT format('%I.%I = %I.%I', target_table, lower(pk), temp_table_name, lower(pk))
                    FROM unnest(pk_columns) pk
                ), ' AND ')
            );
            EXECUTE sql_statement;

            -- Drop the temporary table
            EXECUTE format('DROP TABLE %I', temp_table_name);

        EXCEPTION WHEN OTHERS THEN
            -- Ensure temporary table is dropped even if an error occurs
            EXECUTE format('DROP TABLE IF EXISTS %I', temp_table_name);
            RAISE;
        END;
        $function$
    ;
    ```

4. Create function to sync all enabled tables based on their frequency in `cron_table_sync_config`:

    ```sql
    CREATE OR REPLACE FUNCTION public.sync_all_tables()
        RETURNS void
        LANGUAGE plpgsql
        AS $function$
        DECLARE
            config_row RECORD;
            start_time timestamp;
            end_time timestamp;
            rows_affected bigint;
            rows_deleted bigint;
        BEGIN
            FOR config_row IN 
                SELECT * FROM cron_table_sync_config 
                WHERE enabled = true 
                AND (last_sync_time IS NULL OR 
                    current_timestamp - last_sync_time >= sync_frequency)
            LOOP
                BEGIN
                    start_time := clock_timestamp();
                    
                    -- Get initial row count
                    EXECUTE format('SELECT count(*) FROM %I', config_row.target_table) INTO rows_affected;

                    -- Perform the sync operation
                    PERFORM sync_table_data(
                        config_row.source_table,
                        config_row.target_table,
                        config_row.primary_keys,
                        config_row.target_updated_date_field
                    );

                    end_time := clock_timestamp();
                    
                    -- Get final row count and calculate deleted rows
                    EXECUTE format('SELECT count(*) FROM %I', config_row.target_table) 
                    INTO rows_deleted;
                    rows_deleted := rows_affected - rows_deleted;
                    rows_affected := rows_affected + rows_deleted;

                    -- Log successful sync
                    INSERT INTO sync_operation_logs (
                        source_table,
                        target_table,
                        start_time,
                        end_time,
                        status,
                        rows_affected,
                        message
                    ) VALUES (
                        config_row.source_table,
                        config_row.target_table,
                        start_time,
                        end_time,
                        'SUCCESS',
                        rows_affected,
                        format('Synced %s rows (Deleted %s rows)', rows_affected, rows_deleted)
                    );
                    
                    -- Update last sync time
                    UPDATE cron_table_sync_config 
                    SET last_sync_time = end_time 
                    WHERE id = config_row.id;

                EXCEPTION WHEN OTHERS THEN
                    -- Log error
                    INSERT INTO sync_operation_logs (
                        source_table,
                        target_table,
                        start_time,
                        end_time,
                        status,
                        message
                    ) VALUES (
                        config_row.source_table,
                        config_row.target_table,
                        start_time,
                        clock_timestamp(),
                        'ERROR',
                        SQLERRM
                    );
                    
                    -- Continue with next table
                    CONTINUE;
                END;
            END LOOP;
        END;
        $function$
        ;
    ```

5. Schedule the `sync_all_tables` function to run at a desired interval (e.g., every minute):

    There are default function to schedule cron jobs in the `cron` schema. You can use `cron.schedule_in_database` to schedule the job with more control.

    Here is the definition of `cron.schedule_in_database`:
    
    ``` sql
    CREATE OR REPLACE FUNCTION cron.schedule_in_database(job_name text, schedule text, command text, database text, username text DEFAULT NULL::text, active boolean DEFAULT true)
    RETURNS bigint
    LANGUAGE c
    AS '$libdir/pg_cron', $function$cron_schedule_named$function$
    ;    
    ```

    To schedule the job, run:

    ```sql
    select cron.schedule_in_database('job_name','* * * * *', 'SELECT public.sync_all_tables()','app','app', true);
    ```

6. Insert configuration for tables to sync:

    ```sql
    INSERT INTO public.cron_table_sync_config (source_table, target_table, primary_keys, target_updated_date_field, enabled, sync_frequency)
    VALUES 
    ('oracle_employees', 'employees', ARRAY['employee_id'], 'updated_at', true, '00:05:00'::interval)
    ```